window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ML_Software.counting_boats", "modulename": "ML_Software.counting_boats", "kind": "module", "doc": "<p>This package contains the code for the Counting Boats project. \nthe module boat_utils contains the core functionality for the project,\nwhile the top-level scripts in this package are for running different parts of the project. </p>\n\n<h2 id=\"analysis\">analysis</h2>\n\n<p>poorly documented and largely useless analysis functions - you probably don't need to look at this. Left here just in case</p>\n\n<h2 id=\"classify\">classify</h2>\n\n<p>The main classification script. This is the script that you'll run to detect boats in new images.</p>\n\n<h2 id=\"plot_output\">plot_output</h2>\n\n<p>A script for plotting boats onto their original images.</p>\n\n<h2 id=\"testing\">testing</h2>\n\n<p>A script for running testing/validation on the classification model.</p>\n\n<h2 id=\"train\">train</h2>\n\n<p>A script for training the classification model and preparing / reporting on the training dataset.</p>\n\n<p>Date: 17/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.analysis", "modulename": "ML_Software.counting_boats.analysis", "kind": "module", "doc": "<p>A few analysis functions. These are not fully polished at all and poorly documented but are left here for reference.</p>\n\n<p>Author: Charlie Turner\nDate: 19/03/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.analysis.aoi_of_point", "modulename": "ML_Software.counting_boats.analysis", "qualname": "aoi_of_point", "kind": "function", "doc": "<p>given a lat/lon, find the aoi it is in.\n@param lat: latitude of point\n@param lon: longitude of point\n@param aois: list of polygon files</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">lon</span>, </span><span class=\"param\"><span class=\"n\">aois</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.get_data", "modulename": "ML_Software.counting_boats.analysis", "qualname": "get_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.get_coverage", "modulename": "ML_Software.counting_boats.analysis", "qualname": "get_coverage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.plot_total_count_per_week", "modulename": "ML_Software.counting_boats.analysis", "qualname": "plot_total_count_per_week", "kind": "function", "doc": "<p>Plot the count of boats each week of the year for all years in teh data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.plot_avg_count_per_week", "modulename": "ML_Software.counting_boats.analysis", "qualname": "plot_avg_count_per_week", "kind": "function", "doc": "<p>Plot the average count of boats per week of the year for all given data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.plot_avg_count_per_dayofweek", "modulename": "ML_Software.counting_boats.analysis", "qualname": "plot_avg_count_per_dayofweek", "kind": "function", "doc": "<p>Plot the average count of boats per day of the week for all given data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.map_scatter", "modulename": "ML_Software.counting_boats.analysis", "qualname": "map_scatter", "kind": "function", "doc": "<p>Plot a scatter plot of the total count of boats on a satellite image</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.chloro_coverage", "modulename": "ML_Software.counting_boats.analysis", "qualname": "chloro_coverage", "kind": "function", "doc": "<p>Add coverage grid from geojson to an exisitng figure</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">geojson_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.create_and_show_heatmap", "modulename": "ML_Software.counting_boats.analysis", "qualname": "create_and_show_heatmap", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coverage_file</span>, </span><span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.analysis.plot_boats", "modulename": "ML_Software.counting_boats.analysis", "qualname": "plot_boats", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils", "modulename": "ML_Software.counting_boats.boat_utils", "kind": "module", "doc": "<p>This module contains utility functions for the counting boats project.\nThese in general should not be called directly, and are imported by other modules as needed.</p>\n\n<p>Author: Charlie Turner</p>\n\n<p>Date: 17/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "kind": "module", "doc": "<p>This module contains functions which help with the automatic detection pipeline.</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.get_history", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "get_history", "kind": "function", "doc": "<p>Parse and return the csv file at the provided path.\nCreates the file if not exists, with the headings:\n\"order_id, AOI, date, order_status, area_coverage, cloud_coverage\"</p>\n\n<p>Args:\n    csv_path: path to the csv file</p>\n\n<p>Returns:\n    DataFrame of the csv file, or a new DataFrame with the header if the file does not exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.save_history", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "save_history", "kind": "function", "doc": "<p>Save the history DataFrame to the csv file at the provided path.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">history</span>, </span><span class=\"param\"><span class=\"n\">csv_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.search", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "search", "kind": "function", "doc": "<p>Search for images using the Planet API for the given AOI. Will search for the last 14 days by default,\nor between the start and end dates if provided.</p>\n\n<p>Args:\n    aoi: Area of Interest name\n    orders_csv_path: path to the history csv\n    days: number of days to search back from the current date\n    start_date: start date to search from (inclusive)\n    end_date: end date to search to (inclusive)</p>\n\n<p>Returns:\n    tuple of:\n        options: list of options from the search\n        dates: list of dates that we don't already have in the history</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">aoi</span>,</span><span class=\"param\">\t<span class=\"n\">orders_csv_path</span>,</span><span class=\"param\">\t<span class=\"n\">days</span><span class=\"o\">=</span><span class=\"mi\">14</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.select", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "select", "kind": "function", "doc": "<p>Select images from the given options that are not in history for the AOI, and within \nthe provided dates.</p>\n\n<p>Args:\n    aoi: Area of Interest name\n    options: list of options\n    dates: list of dates that we want to select for</p>\n\n<p>Returns:\n    list of: list of items for each date.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">aoi</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">dates</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.order", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "order", "kind": "function", "doc": "<p>Place a Planet order for the given items. Items will be composited, so\nonly one order should be placed per day. Items should be from the same\nAOI as only one tif is returned per order, with all items composited.</p>\n\n<p>Args:\n    aoi: Area of Interest name\n    items: list of items to order\n    csv_path: path to the order history csv</p>\n\n<p>Returns:\n    order_id: the ID of the order placed</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">aoi</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">items</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.download", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "download", "kind": "function", "doc": "<p>Download all completed orders from planet, as per the history csv path\nPlaces the downloaded files in the download_path. If start_date and end_date are provided,\nwill only download orders from between those dates.</p>\n\n<p>Args:\n    csv_path: path to the history csv. Will check this to ensure we don't download the same file twice.\n    download_path: path to store the downloaded zip files\n    start_date: start date to download from (inclusive)\n    end_date: end date to download to (inclusive)</p>\n\n<p>Returns:\n    Any remaining orders that haven't been downloaded yet</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">download_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;tempDL&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.extract", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "extract", "kind": "function", "doc": "<p>Extract any downloaded images we haven't processed. Will \nextract all images if start_date and end_date are None, otherwise\nwill only extract images between those dates.</p>\n\n<p>Args:\n    download_path: path to the downloaded zip files\n    start_date: start date to extract from\n    end_date: end date to extract to</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">download_path</span>, </span><span class=\"param\"><span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.count", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "count", "kind": "function", "doc": "<p>Run the classifier to count boats in the extracted images</p>\n\n<p>Essentially calls the main function of the classifier module. Most of the time here we will save coverage later, \nso we don't need to save it here. </p>\n\n<p>Args:\n    save_coverage: whether to save the coverage of the images\n    days: the number of days to count boats for</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">save_coverage</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.save", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "save", "kind": "function", "doc": "<p>Confirm completion of the process and archive the raw data.\nSaves the csv with everything updated.</p>\n\n<p>Args:\n    csv_path: path to the history csv\n    start_date: start date to save from\n    end_date: end date to save to</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span>, </span><span class=\"param\"><span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.groups", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "groups", "kind": "variable", "doc": "<p>Groups of AOIs for analysis</p>\n", "default_value": "[{&#x27;name&#x27;: &#x27;moreton_bay&#x27;, &#x27;aois&#x27;: [&#x27;peel&#x27;, &#x27;tangalooma&#x27;, &#x27;south_bribie&#x27;, &#x27;moreton&#x27;]}]"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.analyse", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "analyse", "kind": "function", "doc": "<p>Do a series of analyses on the data and save it in the output directory. Also log to comet if an experiment is provided.\nLots of the time parts of this function will be commented out, as we don't always want to do everything because its expensive.</p>\n\n<p>Args:\n    csv_path: path to the history csv\n    coverage_path: path to the coverage csv (should be generated when images are archived)\n    start_date: start date to analyse from\n    end_date: end date to analyse to\n    id: id to prefix the output files with\n    exp: comet experiment to log to\n    batch: the batch number</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">boat_csv_path</span>,</span><span class=\"param\">\t<span class=\"n\">coverage_path</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">exp</span><span class=\"p\">:</span> <span class=\"n\">comet_ml</span><span class=\"o\">.</span><span class=\"n\">_online</span><span class=\"o\">.</span><span class=\"n\">Experiment</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">batch</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.auto_helpers.archive", "modulename": "ML_Software.counting_boats.boat_utils.auto_helpers", "qualname": "archive", "kind": "function", "doc": "<p>Deal with folder of raw data after processing. Send zip files to archive,\ndelete the folders, update coverage file. Start and end dates are optional.</p>\n\n<p>Args:\n    path: path to the folder of raw data\n    coverage_path: path to the coverage csv\n    start_date: start date to archive from\n    end_date: end date to archive to</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">coverage_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">start_date</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">end_date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.TEMP", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "TEMP", "kind": "variable", "doc": "<p>Temporary directory for storing images</p>\n", "default_value": "&#x27;C:\\\\ML_Software\\\\Boat_Temp&#x27;"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.TEMP_PNG", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "TEMP_PNG", "kind": "variable", "doc": "<p>Temporary directory for storing png version of tif images</p>\n", "default_value": "&#x27;C:\\\\ML_Software\\\\Boat_Temp_PNG&#x27;"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.TILE_SIZE", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "TILE_SIZE", "kind": "variable", "doc": "<p></p>\n", "default_value": "416"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.STRIDE", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "STRIDE", "kind": "variable", "doc": "<p></p>\n", "default_value": "104"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.SAVE_COVERAGE", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "SAVE_COVERAGE", "kind": "variable", "doc": "<p></p>\n", "default_value": "True"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.model", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "model", "kind": "variable", "doc": "<p></p>\n", "default_value": "AutoShape(\n  (model): DetectMultiBackend(\n    (model): DetectionModel(\n      (model): Sequential(\n        (0): Conv(\n          (conv): Conv2d(3, 32, kernel_size=(6, 6), stride=(2, 2), padding=(2, 2))\n          (act): SiLU(inplace=True)\n        )\n        (1): Conv(\n          (conv): Conv2d(32, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (2): C3(\n          (cv1): Conv(\n            (conv): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(32, 32, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (3): Conv(\n          (conv): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (4): C3(\n          (cv1): Conv(\n            (conv): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n            (1): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (5): Conv(\n          (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (6): C3(\n          (cv1): Conv(\n            (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n            (1): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n            (2): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (7): Conv(\n          (conv): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (8): C3(\n          (cv1): Conv(\n            (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(512, 512, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (9): SPPF(\n          (cv1): Conv(\n            (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): MaxPool2d(kernel_size=5, stride=1, padding=2, dilation=1, ceil_mode=False)\n        )\n        (10): Conv(\n          (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (11): Upsample(scale_factor=2.0, mode=&#x27;nearest&#x27;)\n        (12): Concat()\n        (13): C3(\n          (cv1): Conv(\n            (conv): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (14): Conv(\n          (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (15): Upsample(scale_factor=2.0, mode=&#x27;nearest&#x27;)\n        (16): Concat()\n        (17): C3(\n          (cv1): Conv(\n            (conv): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (18): Conv(\n          (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (19): Concat()\n        (20): C3(\n          (cv1): Conv(\n            (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (21): Conv(\n          (conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n          (act): SiLU(inplace=True)\n        )\n        (22): Concat()\n        (23): C3(\n          (cv1): Conv(\n            (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv2): Conv(\n            (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (cv3): Conv(\n            (conv): Conv2d(512, 512, kernel_size=(1, 1), stride=(1, 1))\n            (act): SiLU(inplace=True)\n          )\n          (m): Sequential(\n            (0): Bottleneck(\n              (cv1): Conv(\n                (conv): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n              (cv2): Conv(\n                (conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n                (act): SiLU(inplace=True)\n              )\n            )\n          )\n        )\n        (24): Detect(\n          (m): ModuleList(\n            (0): Conv2d(128, 21, kernel_size=(1, 1), stride=(1, 1))\n            (1): Conv2d(256, 21, kernel_size=(1, 1), stride=(1, 1))\n            (2): Conv2d(512, 21, kernel_size=(1, 1), stride=(1, 1))\n          )\n        )\n      )\n    )\n  )\n)"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.main", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "main", "kind": "function", "doc": "<p>Run the classifier on each image in the directory given in the configuration.\nReturn the name of each directory which is successfully processed.\n@require cfg: The configuration file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">save_coverage</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.process_tif", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "process_tif", "kind": "function", "doc": "<p>Processes a single tif file</p>\n\n<p>Args:\n    file: The tif file to process\n    img_path: The path to the directory to store the data in\n    stat_cutoff: The cutoff for static boats (pixels)\n    moving_cutoff: The cutoff for moving boats (pixels)\nReturns:\n    A tuple of the static boats and moving boats\n    With boats as a list of: [x, y, filename]</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">stat_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">moving_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.process_day", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "process_day", "kind": "function", "doc": "<p>Process a day's images. Runs process_tif for each of the given files,\nand then clusters and processes the results.</p>\n\n<p>Args:\n    files: The files to process\n    img_path: The path to the directory to store the data in\n    stat_cutoff: The cutoff for static boats (pixels)\n    moving_cutoff: The cutoff for moving boats (pixels)\n    day: The day to process\n    i: The index of the day\n    n_days: The total number of days</p>\n\n<p>Returns:\n    A tuple of the static boats, moving boats, and the day\n    With boats as a list of: [x, y, confidence, class, width, height, filename]</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">files</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">stat_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">moving_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">day</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_days</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.classify_directory", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "classify_directory", "kind": "function", "doc": "<p>Use for directory of tiff images. Preprocesses, classifies, clusters.\nWrites the results to a csv file called boat_detections.csv in the output directory</p>\n\n<p>Args:\n    directory: The directory to classify\n    classify_days: list of days to classify in format \"DD/MM/YYYY\"</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span>, </span><span class=\"param\"><span class=\"n\">classify_days</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.classify_images", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "classify_images", "kind": "function", "doc": "<p>Use when images are already split into tiled images.\nSimply runs the classifier and clusters.</p>\n\n<p>Args:\n    images_dir: The directory containing the images\n    STAT_DISTANCE_CUTOFF_PIX: The cutoff for static boats (pixels)\n    OUTFILE: The output file name</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">images_dir</span>, </span><span class=\"param\"><span class=\"n\">STAT_DISTANCE_CUTOFF_PIX</span>, </span><span class=\"param\"><span class=\"n\">OUTFILE</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.classify_text", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "classify_text", "kind": "function", "doc": "<p>If images have been classified and the text files are available, use this.\nClusters and collates from yolov5 text files.</p>\n\n<p>Args:\n    dir: The directory containing the text files\n    STAT_DISTANCE_CUTOFF_PIX: The cutoff for static boats (pixels)\n    OUTFILE: The output file name\n    save_clusters: Whether to save the clusters to csv before processing</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"nb\">dir</span>,</span><span class=\"param\">\t<span class=\"n\">STAT_DISTANCE_CUTOFF_PIX</span>,</span><span class=\"param\">\t<span class=\"n\">OUTFILE</span>,</span><span class=\"param\">\t<span class=\"n\">day</span><span class=\"o\">=</span><span class=\"s1\">&#39;unknown&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">save_clusters</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.prepare_temp_dirs", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "prepare_temp_dirs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.detect_from_tif", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "detect_from_tif", "kind": "function", "doc": "<p>Detect from a tif file</p>\n\n<p>Args:\n    file: The tif file to detect from\n    tif_dir: The directory containing the tif file\n    yolo_dir: The directory containing yolo\n    python: The python executable to use\n    weights: The weights to use for the NN\n    confidence_threshold: The confidence threshold to use where if confidence &lt; threshold, it is considered low confidence</p>\n\n<p>Returns:\n    A tuple of the classifications and low confidence classifications\n    With boats as a list of: [x, y, confidence, class, width, height]</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file</span>,</span><span class=\"param\">\t<span class=\"n\">tif_dir</span>,</span><span class=\"param\">\t<span class=\"n\">yolo_dir</span>,</span><span class=\"param\">\t<span class=\"n\">python</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">confidence_threshold</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.detect_from_dir", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "detect_from_dir", "kind": "function", "doc": "<p>Detect from a directory containing images</p>\n\n<p>Args:\n    dir: The directory containing the images\n    yolo_dir: The directory containing yolo\n    python: The python executable to use\n    weights: The weights to use for the NN\n    confidence_threshold: The confidence threshold to use where if confidence &lt; threshold, it is considered low confidence</p>\n\n<p>Returns:\n    A tuple of the classifications and low confidence classifications\n    With boats as a list of: [x, y, confidence, class, width, height]</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"nb\">dir</span>,</span><span class=\"param\">\t<span class=\"n\">yolo_dir</span>,</span><span class=\"param\">\t<span class=\"n\">python</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">confidence_threshold</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.classification_file_info", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "classification_file_info", "kind": "function", "doc": "<p>Get information and data from a small png file\nThe file-name is in the format: &lt;.*>_<row>_<col>.txt</p>\n\n<p>Args:\n    file: The file path to get information from</p>\n\n<p>Returns:\n    The across, down, and data from the file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.parse_classifications", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "parse_classifications", "kind": "function", "doc": "<p>parse a single text file of classifications into the desired format</p>\n\n<p>Args:\n    file: path to text file with classifications in form:\n    class, x, y, w, h, conf</p>\n\n<p>Returns:\n    array of classifications from the file in the form:\n    x, y, confidence, class, width, height</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.remove_low_confidence", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "remove_low_confidence", "kind": "function", "doc": "<p>Remove all classifications with confidence &lt; confidence_threshold</p>\n\n<p>Args:\n    classifications: The classifications to remove low confidence from. Confidence is the third column.\n    confidence_threshold: The threshold to remove below</p>\n\n<p>Returns:\n    The same classifications as a tuple, with the first element being the high confidence classifications</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">classifications</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">confidence_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.read_classifications", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "read_classifications", "kind": "function", "doc": "<p>Read classifications from either the given directory, or the latest detection from yolo.\nClassifications are per-image, this function reads all files and returns a single list.</p>\n\n<p>Args:\n    yolo_dir: The directory where yolo is installed, used to find the latest detection.\n    class_folder: The folder to read classifications from. If None, reads from the latest detection in yolo.\n    confidence_threshold = 0.5: The confidence threshold to use when separating low confidence classifications.\n    delete_folder: Whether to delete the classification folder after reading.</p>\n\n<p>Returns:\n    tuple[classifications, low_conf]: where each is in the form (x, y, conf, class, w, h)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">yolo_dir</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">class_folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">confidence_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">delete_folder</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.cluster", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "cluster", "kind": "function", "doc": "<p>Cluster the given classifications using the given cutoff.</p>\n\n<p>Args:\n    classifications: The classifications to cluster, in the form x, y, confidence, class, width, height\n    cutoff: The cutoff to use for clustering</p>\n\n<p>Returns:\n    The classifications with an additional column for the cluster number\n    Columns: x, y, confidence, class, width, height, filename, cluster</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">classifications</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.process_clusters", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "process_clusters", "kind": "function", "doc": "<p>Process the given classifications with clusters. Condenses each cluster into a single point.</p>\n\n<p>Args:\n    classifications_with_clusters: The classifications as x, y, confidence, class, width, height, filename, cluster</p>\n\n<p>Return:\n    An array of the condensed classifications in the form: x, y, confidence, class, width, height, filenames</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">classifications_with_clusters</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.condense", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "condense", "kind": "function", "doc": "<p>Given a cluster, condense it into a single point.\nUses the mean of x, y, w, and h - the most common class, and the maximum confidence.</p>\n\n<p>Args:\n    cluster: The cluster to condense</p>\n\n<p>Returns:\n    The condensed cluster in the form x, y, confidence, class, width, height, filenames</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cluster</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.write_to_csv", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "write_to_csv", "kind": "function", "doc": "<p>Write the given classifications to a csv file.</p>\n\n<p>Args:\n    classifications: The classifications to write\n    day: The day the classifications are from\n    file: The file to write to</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">classifications</span>, </span><span class=\"param\"><span class=\"n\">day</span>, </span><span class=\"param\"><span class=\"n\">filepath</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.save_coverage", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "save_coverage", "kind": "function", "doc": "<p>Save the coverage polygons to the coverage file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">day</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.remove", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "remove", "kind": "function", "doc": "<p>Removes all files in a folder and the folder itself.</p>\n\n<p>Args:\n    path: The path to remove\n    del_folder: Whether to remove the folder itself</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">del_folder</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.classifier.pixel2latlong", "modulename": "ML_Software.counting_boats.boat_utils.classifier", "qualname": "pixel2latlong", "kind": "function", "doc": "<p>Convert the given classifications from pixel coordinates to lat/long.</p>\n\n<p>Args:\n    classifications: The classifications to convert, must have x, y as first two columns.\n    tif: The tif file these classifications came from.</p>\n\n<p>Returns:\n    The same classifications with x, y converted to lat/long</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">classifications</span>, </span><span class=\"param\"><span class=\"n\">tif</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.config", "modulename": "ML_Software.counting_boats.boat_utils.config", "kind": "module", "doc": "<p>Load and parse the config file for other modules</p>\n\n<p>usage:</p>\n\n<pre><code>from boat_utils.config import cfg\n</code></pre>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.config.config_path", "modulename": "ML_Software.counting_boats.boat_utils.config", "qualname": "config_path", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;C:\\\\ML_Software\\\\config.yml&#x27;"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "kind": "module", "doc": "<p>Given a heap of polygons, create a heatmap of the density of seeing each area.</p>\n\n<ol>\n<li>Bounding box of all the polygons\n<ul>\n<li>This is then the area for the 'heatmap'</li>\n<li>Can alternatively just use a big polygon that covers the area</li>\n</ul></li>\n<li>Represent the bounding box by a grid of pixels \n<ul>\n<li>This so that the heatmap can be represented by a 2D array</li>\n</ul></li>\n<li>For each polygon:\n<ul>\n<li>'paint' the polygon onto the heatmap by adding 1 to each pixel that is\ncovered by the polygon</li>\n</ul></li>\n</ol>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.get_bbox", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "get_bbox", "kind": "function", "doc": "<p>Get the bounding box of a list of polygons.</p>\n\n<p>Args:</p>\n\n<pre><code>polygons: List of polygons, must be in global coordinate system (not latlong)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>x_min: Minimum x value\n\nx_max: Maximum x value\n\ny_min: Minimum y value\n\ny_max: Maximum y value\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span> <span class=\"o\">|</span> <span class=\"kc\">None</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.get_polygons_from_folder", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "get_polygons_from_folder", "kind": "function", "doc": "<p>Get the polygons from a folder of json files.</p>\n\n<p>Args:</p>\n\n<pre><code>folder: Path to folder\n\nname: Optional, name of file to search for\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>List of polygons in global coordinate system EPSG:32756\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.get_polygons_from_file", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "get_polygons_from_file", "kind": "function", "doc": "<p>Get the polygons from a csv file with 'polygon' column.\nGroup optionally is a group of aois to use</p>\n\n<p>Args:</p>\n\n<pre><code>csv_path: Path to csv file\ngroup: Optional, list of aois to use\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>List of polygons in global coordinate system EPSG:32756\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span>, </span><span class=\"param\"><span class=\"n\">group</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.get_polygons_from_df", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "get_polygons_from_df", "kind": "function", "doc": "<p>Get the polygons from a dataframe with 'polygon' column.\nGroup optionally is a group of aois to use</p>\n\n<p>Args:</p>\n\n<pre><code>df: Dataframe with 'polygon' column\ngroup: Optional, list of aois to use\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>List of polygons in global coordinate system EPSG:32756\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">group</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span> <span class=\"o\">|</span> <span class=\"kc\">None</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.create_grid", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "create_grid", "kind": "function", "doc": "<p>Create's a grid of pixels that covers the area of the bounding box.</p>\n\n<p>Args:</p>\n\n<pre><code>x_min: Minimum x value\nx_max: Maximum x value\ny_min: Minimum y value\ny_max: Maximum y value\nsize: Size of each pixel in meters\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>A tuple of:\n    grid: 2D numpy array of zeros\n    x_step: Size of each pixel in x direction\n    y_step: Size of each pixel in y direction\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x_min</span>,</span><span class=\"param\">\t<span class=\"n\">x_max</span>,</span><span class=\"param\">\t<span class=\"n\">y_min</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span>,</span><span class=\"param\">\t<span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.paint_grid", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "paint_grid", "kind": "function", "doc": "<p>Populate the given grid as per whether each pixel's center is covered by the polygon.</p>\n\n<p>Args:</p>\n\n<pre><code>grid: 2D numpy array of zeros\nx_min: Minimum x value\nx_max: Maximum x value\ny_min: Minimum y value\ny_max: Maximum y value\nx_step: Size of each pixel in x direction\ny_step: Size of each pixel in y direction\npoly: Polygon to paint onto the grid\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">x_min</span>, </span><span class=\"param\"><span class=\"n\">x_max</span>, </span><span class=\"param\"><span class=\"n\">y_min</span>, </span><span class=\"param\"><span class=\"n\">y_max</span>, </span><span class=\"param\"><span class=\"n\">x_step</span>, </span><span class=\"param\"><span class=\"n\">y_step</span>, </span><span class=\"param\"><span class=\"n\">poly</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.export_data", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "export_data", "kind": "function", "doc": "<p>Export the grid as a GEOTIFF.</p>\n\n<p>Args:</p>\n\n<pre><code>grid: 2D numpy array of zeros\nx_min: Minimum x value\nx_max: Maximum x value\ny_min: Minimum y value\ny_max: Maximum y value\nx_step: Size of each pixel in x direction\ny_step: Size of each pixel in y direction\nfilename: Name of file to save\ngeojson: Whether to save a geojson file as well\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span>,</span><span class=\"param\">\t<span class=\"n\">x_max</span>,</span><span class=\"param\">\t<span class=\"n\">y_min</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span>,</span><span class=\"param\">\t<span class=\"n\">x_step</span>,</span><span class=\"param\">\t<span class=\"n\">y_step</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;heatmap.tif&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">geojson</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.grid_to_geojson", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "grid_to_geojson", "kind": "function", "doc": "<p>Convert the grid to a geojson file, where each feature is a square in the grid and has:</p>\n\n<ul>\n<li>id: The id of the square</li>\n<li>value: The value of the square (number of times this square was painted on)</li>\n</ul>\n\n<p>Args:</p>\n\n<pre><code>grid: 2D numpy array of zeros\nx_min: Minimum x value\nx_max: Maximum x value\ny_min: Minimum y value\ny_max: Maximum y value\nx_step: Size of each pixel in x direction\ny_step: Size of each pixel in y direction\nfilename: Name of file to save\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span>,</span><span class=\"param\">\t<span class=\"n\">x_max</span>,</span><span class=\"param\">\t<span class=\"n\">y_min</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span>,</span><span class=\"param\">\t<span class=\"n\">x_step</span>,</span><span class=\"param\">\t<span class=\"n\">y_step</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;heatmap.geojson&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.polygon_from_tif", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "polygon_from_tif", "kind": "function", "doc": "<p>Get the coordinates of a polygon from a tif file.</p>\n\n<p>Args:</p>\n\n<pre><code>tif: Path to tif file\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>List of polygons as ogr polygons in the source coordinate system of the tif\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tif</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.add_to_heatmap", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "add_to_heatmap", "kind": "function", "doc": "<p>Add polygons to the heatmap. Does this by creating a new raster,\nthen adding the polygons to the raster, and then adding the rasters\ntogether.</p>\n\n<p>Args:</p>\n\n<pre><code>heatmap: Path to raster file e.g. 'heatmap.tif'\npolygons: List of polygons as ogr polygons\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">heatmap</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.heatmap.create_heatmap_from_polygons", "modulename": "ML_Software.counting_boats.boat_utils.heatmap", "qualname": "create_heatmap_from_polygons", "kind": "function", "doc": "<p>Create and save a heatmap from a list of polygons.\nOptionally show the heatmap.</p>\n\n<p>Args:</p>\n\n<pre><code>polygons: List of polygons\nsave_file: Name of file to save\nshow: Whether to show the heatmap\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span> <span class=\"o\">|</span> <span class=\"kc\">None</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">save_file</span><span class=\"o\">=</span><span class=\"s1\">&#39;heatmap.tif&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification", "kind": "class", "doc": "<p>This class is used to reference each of the classifications made using labelme that are stored in the output csv</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.__init__", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.__init__", "kind": "function", "doc": "<p>Instantiate the object.</p>\n\n<p>Args:</p>\n\n<pre><code>left: The left edge of the classification\nright: The right edge of the classification\ntop: The top edge of the classification\nbottom: The bottom edge of the classification\nlabel: The label assigned to the classification\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">left</span>, </span><span class=\"param\"><span class=\"n\">right</span>, </span><span class=\"param\"><span class=\"n\">top</span>, </span><span class=\"param\"><span class=\"n\">bottom</span>, </span><span class=\"param\"><span class=\"n\">label</span></span>)</span>"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.get_left", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.get_left", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.get_right", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.get_right", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.get_top", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.get_top", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.get_bottom", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.get_bottom", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.get_label", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.get_label", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.in_bounds", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.in_bounds", "kind": "function", "doc": "<p>Check if this classification is within a larger bounding box defined by the parameters of this function</p>\n\n<p>Args:</p>\n\n<pre><code>left: The left edge of the classification\nright: The right edge of the classification\ntop: The top edge of the classification\nbottom: The bottom edge of the classification\n</code></pre>\n\n<p>Returns\n    True if the classification is within the bounding box specified; false otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">top</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">bottom</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.Classification.serialise", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "Classification.serialise", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.add_margin", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "add_margin", "kind": "function", "doc": "<p>Pads an OPEN PIL (pillow/python imaging library) image on each edge by the amount specified.</p>\n\n<p>Args:</p>\n\n<pre><code>pil_img: The open PIL image to pad.\nleft: The number of pixels to pad the left edge of the image by.\nright: The number of pixels to pad the right edge of the image by.\ntop: The number of pixels to pad the top edge of the image by.\nbottom: The number of pixels to pad the bottom edge of the image by.\ncolor: What colour the padding should be as a tuple (0, 0, 0) for black (255, 255, 255) for white.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The open PIL image after the padding has been applied\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pil_img</span><span class=\"p\">:</span> <span class=\"n\">PIL</span><span class=\"o\">.</span><span class=\"n\">Image</span><span class=\"o\">.</span><span class=\"n\">Image</span>,</span><span class=\"param\">\t<span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">top</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">bottom</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">color</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"n\">PIL</span><span class=\"o\">.</span><span class=\"n\">Image</span><span class=\"o\">.</span><span class=\"n\">Image</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.process_sub_image_with_labels", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "process_sub_image_with_labels", "kind": "function", "doc": "<p>segments an image and its labels into tiles for use in a neural network.\nThis function is intended to be used with multiprocessing.Pool</p>\n\n<p>Args:</p>\n\n<pre><code>args (tuple): A tuple containing the following elements:\n    - i (int): The row index of the sub-image.\n    - j (int): The column index of the sub-image.\n    - stride (int): The stride value used for sub-image extraction.\n    - sub_image (np.ndarray): The sub-image array.\n    - image (np.ndarray): The original image array.\n    - allImageClassifications (list): List of all image classifications.\n    - remove_empty (bool): Flag indicating whether to remove empty images.\n    - im_outdir (str): Directory path to save processed images.\n    - labels_outdir (str): Directory path to save labels.\n    - empty_counter (multiprocessing.Value): Counter for empty images.\n    - skipped_counter (multiprocessing.Value): Counter for skipped images.\n    - progress (multiprocessing.Value): Progress counter.\n    - lock (multiprocessing.Lock): Lock for synchronizing access to shared resources.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.segment_image", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "segment_image", "kind": "function", "doc": "<p>Segments a large .tif file into smaller .png files for use in a neural network. Also created\nfiles in the IMGtxts directory which contain the annotations present in that sub image.</p>\n\n<p>Args:</p>\n\n<pre><code>image: The large .tif that is to be segmented\njson_file: The json file that contains all the classifications for the image that were made in labelme.\nsize: The desired size (both length and width) of the segmented images.\noverlap_size: The desired amount of overlap that the segmented images should have\nmetadata_components: The metadata of the image - useful if the metadata is stripped out in a previous\n    operation on the image/file.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">json_file</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span>,</span><span class=\"param\">\t<span class=\"n\">stride</span>,</span><span class=\"param\">\t<span class=\"n\">metadata_components</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">remove_empty</span><span class=\"o\">=</span><span class=\"mf\">0.9</span>,</span><span class=\"param\">\t<span class=\"n\">im_outdir</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">labels_outdir</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.segment_image_for_classification_nosave", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "segment_image_for_classification_nosave", "kind": "function", "doc": "<p>Segments a large .tif file into smaller .png files for use in a neural network.\nDoes not save the images to disk, but returns them as an array of views into \na larger numpy array.</p>\n\n<p>Args:</p>\n\n<pre><code>image: The large .tif that is to be segmented\ntile_size: The desired size (both length and width) of the segmented images.\ndata_path: The path to the directory where the segmented images will be saved.\nstride: The desired amount of overlap that the segmented images should have\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The images as an array with:\n    i, j, sub_image, image, data_path\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">data_path</span>, </span><span class=\"param\"><span class=\"n\">tile_size</span>, </span><span class=\"param\"><span class=\"n\">stride</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.process_sub_image", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "process_sub_image", "kind": "function", "doc": "<p>segments an image into tiles for use in a neural network.\nThis function is intended to be used with multiprocessing.Pool</p>\n\n<p>Args:</p>\n\n<pre><code>args (tuple): A tuple containing the following elements:\n    - (i, j, sub_image, image, data_path) (tuple): \n        - i (int): The row index of the sub-image.\n        - j (int): The column index of the sub-image.\n        - sub_image (np.ndarray): The sub-image array.\n        - image (str): The path to the original image file.\n        - data_path (str): The directory path to save processed images.\n    - skipped_counter (multiprocessing.Value): Counter for skipped images.\n    - progress (multiprocessing.Value): Progress counter.\n    - lock (multiprocessing.Lock): Lock for synchronizing access to shared resources.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.segment_image_for_classification", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "segment_image_for_classification", "kind": "function", "doc": "<p>Segments a large .tif file into smaller .png files for use in a neural network.</p>\n\n<p>Args:</p>\n\n<pre><code>image: The large .tif that is to be segmented\ntile_size: The desired size (both length and width) of the segmented images.\ndata_path: The path to the directory where the segmented images will be saved.\nstride: The desired amount of overlap that the segmented images should have\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">data_path</span>, </span><span class=\"param\"><span class=\"n\">tile_size</span>, </span><span class=\"param\"><span class=\"n\">stride</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.create_padded_png", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "create_padded_png", "kind": "function", "doc": "<p>Creates an image which is padded for use in training/classifying within a neural network. Note: this images pads\nthe images expecting that the size of sub-images created from this images will be 416x416 pixels.</p>\n\n<p>Args:</p>\n\n<pre><code>raw_dir: Directory where raw .tif files downloaded from Planet are located\noutput_dir: The name of the directory where the padded .png files will be created.\nfile_name: The name of the .tif file that is to be padded.\ntile_size: The size of the sub-images that will be created from this image.\nstride: The amount of overlap that the sub-images will have.\nrename: The name that the padded image will be saved as. If False, the image will be saved as the original name but with a .png extension.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raw_dir</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span>,</span><span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"o\">=</span><span class=\"mi\">416</span>,</span><span class=\"param\">\t<span class=\"n\">stride</span><span class=\"o\">=</span><span class=\"mi\">104</span>,</span><span class=\"param\">\t<span class=\"n\">rename</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.create_unpadded_png", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "create_unpadded_png", "kind": "function", "doc": "<p>Creates an image which is NOT padded but converts raw .tif to .png files.</p>\n\n<p>Args:</p>\n\n<pre><code>raw_dir: Directory where raw .tif files downloaded from Planet are located\noutput_dir: The name of the directory where the padded .png files will be created.\nfile_name: The name of the .tif file that is to be padded.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raw_dir</span>, </span><span class=\"param\"><span class=\"n\">output_dir</span>, </span><span class=\"param\"><span class=\"n\">file_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_required_padding", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_required_padding", "kind": "function", "doc": "<p>Determines how much padding is required on each edge of an image so that the image lengths and widths will be\ndivisible by 416 and that each part of the images will be seen by the neural networm 16 times in either training\nor classification.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: The path of the file to evaluate.\ntilesize: The size of the sub-images that will be created from this image.\nstride: The amount of overlap that the sub-images will have.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(L, R, T, B) - A tuple containing the padding required on the left (L), right (R), top (T), and bottom (b)\n    of the images to make it suitable for use in the neural network.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filepath</span>, </span><span class=\"param\"><span class=\"n\">tilesize</span><span class=\"o\">=</span><span class=\"mi\">416</span>, </span><span class=\"param\"><span class=\"n\">stride</span><span class=\"o\">=</span><span class=\"mi\">104</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_crs", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_crs", "kind": "function", "doc": "<p>Get the EPSG code of the coordinate reference system of a .tif file.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: The path of the file to evaluate.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The EPSG code of the coordinate reference system of the .tif file.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.pixel2coord", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "pixel2coord", "kind": "function", "doc": "<p>Returns global coordinates to pixel center using base-0 raster index</p>\n\n<pre><code>Args:\n\n    x: The x coordinate (pixel coordinates) of the object in the image to be converted to global coordinates.\n    y: The y coordinate (pixel coordinates) of the object in the image to be converted to global coordinates.\n    original_image_path: The path of the file to evaluate - a .tif files should be located here. This file will\n        also need geospatial metadata. Images obtained from Planet have the required metadata.\n</code></pre>\n\n<p>e\n    Returns:</p>\n\n<pre><code>    (xp, yp) - A tuple containing the global coordinates of the provided pixel coordinates.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">original_image_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.coord2pixel", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "coord2pixel", "kind": "function", "doc": "<p>Returns pixel coordinates to pixel center using base-0 raster index</p>\n\n<p>Args:</p>\n\n<pre><code>x: The x coordinate (global coordinates) of the object in the image to be converted to pixel coordinates.\ny: The y coordinate (global coordinates) of the object in the image to be converted to pixel coordinates.\noriginal_image_path: The path of the file to evaluate - a .tif files should be located here. This file will\n    also need geospatial metadata. Images obtained from Planet have the required metadata.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(xp, yp) - A tuple containing the pixel coordinates of the provided global coordinates.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">original_image_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.coord2latlong", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "coord2latlong", "kind": "function", "doc": "<p>Converts global coordinates to latitude/longitude coordinates</p>\n\n<p>Args:</p>\n\n<pre><code>x: The x coordinate in a pair of global coordinates.\ny: The y coordinate in a pair of global coordinates.\ncrs: The coordinate reference system of the global coordinates.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(long, lat) - A tuple containing the longitude and latitude at the provided global coordinates.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">crs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">32756</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.latlong2coord", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "latlong2coord", "kind": "function", "doc": "<p>Converts latitude/longitude coordinates to global coordinates</p>\n\n<p>Args:</p>\n\n<pre><code>long: The longitude coordinate in a pair of latitude/longitude coordinates.\nlat: The latitude coordinate in a pair of latitude/longitude coordinates.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(x, y) - A tuple containing the global coordinates at the provided latitude/longitude coordinates.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">long</span>, </span><span class=\"param\"><span class=\"n\">crs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">32756</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_date_from_filename", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_date_from_filename", "kind": "function", "doc": "<p>Get the date from a file. The file must have a date in the format \"yyyymmdd_\" at the start of the filename .\nfirst\n    Args:</p>\n\n<pre><code>    filename: The name of the file to extract the date from.\n\nReturns:\n\n    The date in the format \"dd/mm/yyyy\" from the filename.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_cartesian_top_left", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_cartesian_top_left", "kind": "function", "doc": "<p>Calculates the lat long at the top left point of a given satellite image</p>\n\n<p>Args:</p>\n\n<pre><code>metadata_components: The metadata components stripped from a .tif file\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(long, lat) - A tuple containing the longitude and latitude at the top left point of the satellite image.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metadata_components</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_cartesian_top_right", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_cartesian_top_right", "kind": "function", "doc": "<p>Calculates the lat long at the top right point of a given satellite image</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>metadata_components</strong>:  The metadata components stripped from a .tif file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(long, lat) - A tuple containing the longitude and latitude at the top right point of the satellite image.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metadata_components</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_cartesian_bottom_left", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_cartesian_bottom_left", "kind": "function", "doc": "<p>Calculates the lat long at the bottom left point of a given satellite image</p>\n\n<p>Args:</p>\n\n<pre><code>metadata_components: The metadata components stripped from a .tif file\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(long, lat) - A tuple containing the longitude and latitude at the bottom left point of the satellite image\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metadata_components</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.get_cartesian_bottom_right", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "get_cartesian_bottom_right", "kind": "function", "doc": "<p>Calculates the lat long at the bottom right point of a given satellite image</p>\n\n<p>Args:</p>\n\n<pre><code>metadata_components: The metadata components stripped from a .tif file\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(long, lat) - A tuple containing the longitude and latitude at the bottom right point of the\n    satellite image.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metadata_components</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.image_cutting_support.metadata_get_w_h", "modulename": "ML_Software.counting_boats.boat_utils.image_cutting_support", "qualname": "metadata_get_w_h", "kind": "function", "doc": "<p>Obtains the width and height of a given satellite image</p>\n\n<p>Args:</p>\n\n<pre><code>metadata_components: The metadata components stripped from a .tif file\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>(width, height) - A tuple containing the width and height of a given satellite image.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">metadata_components</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "kind": "module", "doc": "<p>A collection of utilities to interact with the Planet API specifically for the counting boats project.\nOpinionated in that there are assumptions made about the desired workflow.</p>\n\n<p>The main functions are:</p>\n\n<ul>\n<li>PlanetSearch: search for imagery in a given area of interest</li>\n<li>PlanetSelect: select a subset of items from a search result</li>\n<li>PlanetOrder: order a given search result</li>\n<li>PlanetCheckOrder: check the status of an order</li>\n</ul>\n\n<p>Author: Charlie Turner\nDate: 17/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.API_KEY", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "API_KEY", "kind": "variable", "doc": "<p></p>\n", "default_value": "$PLANET_API_KEY"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.PlanetSearch", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "PlanetSearch", "kind": "function", "doc": "<p>Search a given area of interest for Planet imagery</p>\n\n<p>Args:</p>\n\n<pre><code>polygon_file: the path to the polygon file\nmin_date: the minimum date to search for (inclusive)\nmax_date: the maximum date to search for (inclusive)\ncloud_cover: the maximum cloud cover to search for\n</code></pre>\n\n<p>Requires:\n    Planet API key be set in environment variable</p>\n\n<p>Returns:</p>\n\n<pre><code>a list of Planet items (json result from API)\n</code></pre>\n\n<p>Raises:\n    Exception: if the API returns a non-200 status code</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">min_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">max_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">cloud_cover</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.PlanetSelect", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "PlanetSelect", "kind": "function", "doc": "<p>Select a subset of items from a search result</p>\n\n<p>Args:</p>\n\n<pre><code>items: the list of items to select from\npolygon: the area of interest to check coverage against (polygon file)\ndate: the date to select\narea_coverage: the minimum area coverage to select\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of selected items\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">items</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">area_coverage</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.PlanetOrder", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "PlanetOrder", "kind": "function", "doc": "<p>Order a given search result.</p>\n\n<p>Args:</p>\n\n<pre><code>itemIDs: a list of item IDs to order\npolygon_file: a geojson file containing the area of interest to clip to\n    must be of format: {\"type\": \"Polygon\", \"coordinates\": [[[lon, lat], ...]]}\nname: the name to give the order\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>a list of order IDs\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">items</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">polygon_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.PlanetCheckOrder", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "PlanetCheckOrder", "kind": "function", "doc": "<p>Check the status of a given order</p>\n\n<p>Args:</p>\n\n<pre><code>orderID: the order ID to check\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the status of the order\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">orderID</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.PlanetDownload", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "PlanetDownload", "kind": "function", "doc": "<p>Download a given order and move the tif file to the raw tiffs directory</p>\n\n<p>Args:</p>\n\n<pre><code>orderID: the order ID to download\naoi: the area of interest\ndate: the date of the image\ndownloadPath: the path to download the file to\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the name of the tif file after extracting\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">orderID</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">aoi</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">date</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">downloadPath</span><span class=\"o\">=</span><span class=\"s1\">&#39;tempDL&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.extract_zip", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "extract_zip", "kind": "function", "doc": "<p>Extract the zip file and move the tif file to the raw tiffs directory</p>\n\n<p>Args:</p>\n\n<pre><code>downloadFile: the path to the zip file\naoi: the area of interest\ndate: the date of the image\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the name of the tif file after extracting\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">downloadFile</span>, </span><span class=\"param\"><span class=\"n\">aoi</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">date</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.get_with_retry", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "get_with_retry", "kind": "function", "doc": "<p>Get a URI with retries, doubling the delay each time.</p>\n\n<p>Args:</p>\n\n<pre><code>uri: the URI to get\nauth: the auth tuple\nretries: the number of retries to attempt\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the response object\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">uri</span>, </span><span class=\"param\"><span class=\"n\">auth</span>, </span><span class=\"param\"><span class=\"n\">retries</span><span class=\"o\">=</span><span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.get_orders", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "get_orders", "kind": "function", "doc": "<p>Get all orders from the Planet API</p>\n\n<p>Returns:</p>\n\n<pre><code>a list of orders which are dictionaries. Contains the order ID, state, etc.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.get_aois", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "get_aois", "kind": "function", "doc": "<p>Get all the areas of interest</p>\n\n<p>Returns:</p>\n\n<pre><code>a list of area of interest names\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.get_polygon_file", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "get_polygon_file", "kind": "function", "doc": "<p>Get the polygon for a given area of interest</p>\n\n<p>Args:</p>\n\n<pre><code>aoi: the area of interest name\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the path to the polygon file\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">aoi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.items_area_coverage", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "items_area_coverage", "kind": "function", "doc": "<p>Given all the items for a particular day, and a polygon, compute the area coverage</p>\n\n<p>Args:</p>\n\n<pre><code>items: a list of items\nAOI: the area of interest polygon\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>the area coverage as a float\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">items</span>, </span><span class=\"param\"><span class=\"n\">AOI</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.planet_utils.SEARCH_BODY", "modulename": "ML_Software.counting_boats.boat_utils.planet_utils", "qualname": "SEARCH_BODY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n        {\\n    &quot;filter&quot;: {\\n        &quot;type&quot;: &quot;AndFilter&quot;,\\n        &quot;config&quot;: [\\n            {\\n                &quot;type&quot;: &quot;GeometryFilter&quot;,\\n                &quot;field_name&quot;: &quot;geometry&quot;,\\n                &quot;config&quot;: POLYGON\\n            },\\n            {\\n                &quot;type&quot;: &quot;OrFilter&quot;,\\n                &quot;config&quot;: [\\n                    {\\n                        &quot;type&quot;: &quot;DateRangeFilter&quot;,\\n                        &quot;field_name&quot;: &quot;acquired&quot;,\\n                        &quot;config&quot;: {\\n                            &quot;gte&quot;: &quot;MIN_DATET00:00:00.000Z&quot;,\\n                            &quot;lte&quot;: &quot;MAX_DATET23:59:59.999Z&quot;\\n                        }\\n                    }\\n                ]\\n            },\\n            {\\n                &quot;type&quot;: &quot;OrFilter&quot;,\\n                &quot;config&quot;: [\\n                    {\\n                        &quot;type&quot;: &quot;AndFilter&quot;,\\n                        &quot;config&quot;: [\\n                            {\\n                                &quot;type&quot;: &quot;AndFilter&quot;,\\n                                &quot;config&quot;: [\\n                                    {\\n                                        &quot;type&quot;: &quot;StringInFilter&quot;,\\n                                        &quot;field_name&quot;: &quot;item_type&quot;,\\n                                        &quot;config&quot;: [\\n                                            &quot;PSScene&quot;\\n                                        ]\\n                                    },\\n                                    {\\n                                        &quot;type&quot;: &quot;AndFilter&quot;,\\n                                        &quot;config&quot;: [\\n                                            {\\n                                                &quot;type&quot;: &quot;AssetFilter&quot;,\\n                                                &quot;config&quot;: [\\n                                                    &quot;basic_analytic_4b&quot;\\n                                                ]\\n                                            }\\n                                        ]\\n                                    }\\n                                ]\\n                            },\\n                            {\\n                                &quot;type&quot;: &quot;RangeFilter&quot;,\\n                                &quot;config&quot;: {\\n                                    &quot;gte&quot;: 0,\\n                                    &quot;lte&quot;: CLOUD_COVER\\n                                },\\n                                &quot;field_name&quot;: &quot;cloud_cover&quot;\\n                            },\\n                            {\\n                                &quot;type&quot;: &quot;StringInFilter&quot;,\\n                                &quot;field_name&quot;: &quot;publishing_stage&quot;,\\n                                &quot;config&quot;: [\\n                                    &quot;standard&quot;,\\n                                    &quot;finalized&quot;\\n                                ]\\n                            }\\n                        ]\\n                    },\\n                    {\\n                        &quot;type&quot;: &quot;AndFilter&quot;,\\n                        &quot;config&quot;: [\\n                            {\\n                                &quot;type&quot;: &quot;StringInFilter&quot;,\\n                                &quot;field_name&quot;: &quot;item_type&quot;,\\n                                &quot;config&quot;: [\\n                                    &quot;SkySatCollect&quot;\\n                                ]\\n                            },\\n                            {\\n                                &quot;type&quot;: &quot;RangeFilter&quot;,\\n                                &quot;config&quot;: {\\n                                    &quot;gte&quot;: 0,\\n                                    &quot;lte&quot;: CLOUD_COVER\\n                                },\\n                                &quot;field_name&quot;: &quot;cloud_cover&quot;\\n                            }\\n                        ]\\n                    }\\n                ]\\n            },\\n            {\\n                &quot;type&quot;: &quot;PermissionFilter&quot;,\\n                &quot;config&quot;: [\\n                    &quot;assets:download&quot;\\n                ]\\n            }\\n        ]\\n    },\\n    &quot;item_types&quot;: [\\n        &quot;PSScene&quot;,\\n        &quot;SkySatCollect&quot;\\n    ]\\n}\\n&#x27;"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "kind": "module", "doc": "<p>This module provides functions for calculating the coverage of polygons and TIFF files.</p>\n\n<p>The main functions in this module are:</p>\n\n<ul>\n<li><code>area_coverage_tif</code>: Calculates the intersection of a polygon and a TIFF file, as a percentage of the polygon area.</li>\n<li><code>area_coverage_poly</code>: Computes the intersection of a polygon and a reference polygon, as a percentage of the reference polygon area.</li>\n<li><code>combine_polygons</code>: Combines two or more (intersecting) polygons into one.</li>\n<li><code>polygons_to_32756</code>: Converts a polygon from latitude-longitude coordinates to EPSG:32756 coordinate system.</li>\n</ul>\n\n<p>These functions are useful for analyzing and measuring the coverage of geographic areas by polygons and TIFF files.</p>\n\n<p>Author: Charlie Turner\nDate: 16/09/24</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.UDM1_CLOUD", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "UDM1_CLOUD", "kind": "variable", "doc": "<p></p>\n", "default_value": "2"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.UDM1_CLEAR", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "UDM1_CLEAR", "kind": "variable", "doc": "<p></p>\n", "default_value": "0"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.create_clear_coverage_tif", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "create_clear_coverage_tif", "kind": "function", "doc": "<p>Same as add_udm_clear_to_tif, but creates a new tif file instead of modifying an existing one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">udm_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;clear.tif&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.get_array_from_tif", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "get_array_from_tif", "kind": "function", "doc": "<p>Get the band from a tif as an array. If grid_size is not None, resample the array to squares of that size in meters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tif_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">band</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.add_udm_clear_to_tif", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "add_udm_clear_to_tif", "kind": "function", "doc": "<p>Given a udm, add the clear coverage to the tif file. E.g, the tif file will\nhave a raster with 1s for clear pixels and 0s for non-clear pixels. So will\nthe udm. This function will alter the tif to then have a 2 for clear pixels in both\nrasters, or 1 if only one raster was clear.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">udm_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">tif_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.use_udm_2", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "use_udm_2", "kind": "function", "doc": "<p>Open a udm, sum the clear pixels (band 1). If 0 return False (old udm has nothing in band 1), else True</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">udm_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.cloud_coverage_udm", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "cloud_coverage_udm", "kind": "function", "doc": "<p>Using the usable data mask (UDM) from Planet, calculate the cloud coverage of the image.\nThe UDM is a raster file with 8 bands, each representing a different variable. Band 6 should\nbe the cloud mask. This function checks the metadata to confirm, then calculates the cloud\npercentage as the proportion of pixels in band 6 that are clouds, and returns the cloud coverage\nmask as a binary array.\nNote: the cloud mask is over the entire extent of the image. Use <code>area_coverage_tif</code> to calculate\nthe coverage of the tif, and then multiply cloud coverage with image coverage to get cloud coverage over\nthe AOI.</p>\n\n<p>Args:</p>\n\n<pre><code>udm_path: path to UDM file (from Planet)\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>A tuple containing, a float (cloud coverage as a proportion of the image), and a numpy array (cloud mask)\nwith 1s for cloud pixels and 0s for non-cloud pixels.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">udm_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.area_coverage_tif", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "area_coverage_tif", "kind": "function", "doc": "<p>Calculate the intersection of a polygon and a tif, as a percentage of the polygon area.\nTo be used when calculating the coverage of a tif file for an AOI, after the TIF has already\nbeen obtained. Assumes the tif is clipped to the polygon (does not check whether the tif is\nactually inside the polygon, just calculates the areas).</p>\n\n<p>Args:</p>\n\n<pre><code>polygon : path to polygon file (geojson format)\ntif     : path to tif file (from Planet)\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>A tuple containing, a float (proportion of polygon covered by tif),\nfloat (area of polygon, m2), float (area of tif, m2)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">tif</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.area_coverage_poly", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "area_coverage_poly", "kind": "function", "doc": "<p>Computes the intersection of a polygon and a reference polygon, as a proportion of the reference polygon area.</p>\n\n<p>Args:</p>\n\n<pre><code>reference: path to reference polygon file (geojson format) SHOULD BE A SINGLE POLYGON\npolygon: path to polygon file (geojson format) Can be a multipolygon\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>The proportion of the reference polygon covered by the polygon\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.combine_polygons", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "combine_polygons", "kind": "function", "doc": "<p>Combines two or more polygons into one</p>\n\n<p>Args:</p>\n\n<p>polygons: list of paths to polygon file (geojson format) or polygon strings (stringified geojson)</p>\n\n<p>Returns</p>\n\n<p>The combined polygon in EPSG:32756 coordinate system</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygons</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.polygon_latlong2crs", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "polygon_latlong2crs", "kind": "function", "doc": "<p>Converts a polygon from lat long to a coordinate system (default EPSG:32756).\nOften polygons will be in geojson, which uses latitude and longitude.</p>\n\n<p>Args:</p>\n\n<pre><code>polygon: one of: path to polygon file (geojson format), polygon string (stringified geojson), or dict representing the polygon. Polygon must be in lat long coordinates.\ncrs: the coordinate system to convert to (default EPSG:32756)\n</code></pre>\n\n<p>Returns</p>\n\n<pre><code>The same polygon, converted to the specified coordinate system, or EPSG:32756 by default\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polygon</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span>,</span><span class=\"param\">\t<span class=\"n\">crs</span><span class=\"o\">=</span><span class=\"mi\">32756</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.spatial_helpers.is_inside", "modulename": "ML_Software.counting_boats.boat_utils.spatial_helpers", "qualname": "is_inside", "kind": "function", "doc": "<p>Check if a point is inside a polygon</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>polygon</strong>:  polygon or list of polygons</li>\n<li><strong>point</strong>:  (lat, long)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>True if point is inside polygon, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polygon</span>, </span><span class=\"param\"><span class=\"n\">point</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.stitch_PNGs", "modulename": "ML_Software.counting_boats.boat_utils.stitch_PNGs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.stitch_PNGs.main", "modulename": "ML_Software.counting_boats.boat_utils.stitch_PNGs", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.stitch_PNGs.stitch", "modulename": "ML_Software.counting_boats.boat_utils.stitch_PNGs", "qualname": "stitch", "kind": "function", "doc": "<p>for each png in the directory, pull out the x, y coords\nimages have names like imagessdfasdf_x_y.png\nThey are all 416x416, and overlap 104 pixels.\nneed to stich them back together into one image</p>\n\n<p>Args:\n    dir (str): directory containing images to stitch</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">dir</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing", "modulename": "ML_Software.counting_boats.boat_utils.testing", "kind": "module", "doc": "<p>Utility functions for training/validation pipeline.<br />\nIncludes: \n    - prepare: Prepare the images for segmentation\n    - segment: Segment the images\n    - run_detection: Run the YoloV5 detection\n    - backwards_annotation: Generate labelme style annotations from the classifications\n    - compare_detections_to_ground_truth: Match up labels and detections, compare them, and save the results\n    - confusion_matrix: Summarize the results of the comparison</p>\n\n<p>Author: Charlie Turner\nDate: 17/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.prepare", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "prepare", "kind": "function", "doc": "<p>Given a folder, find all the tif files are create a png for each one.\nAlso rename tif files if required.</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to prepare\nconfig (dict): The configuration dictionary\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.segment", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "segment", "kind": "function", "doc": "<p>Segment (labelled) png's in the given base.\nPlaces segmented images in the 'SegmentedImages' folder, and Labels in the 'Labels' folder.</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to segment\nconfig (dict): The configuration dictionary\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.run_detection", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "run_detection", "kind": "function", "doc": "<p>Run the YoloV5 detection on the segmented images, and move\nthe detections to a sibling directory for analysis.</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nrun_config (dict): The configuration dictionary.\n</code></pre>\n\n<p>Raises:\n    Exception: If there is an error running detection on a directory.</p>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">run_config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.backwards_annotation", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "backwards_annotation", "kind": "function", "doc": "<p>Generate labelme style annotations (json) from the classifications.</p>\n\n<ol>\n<li>Read classifications</li>\n<li>Generate json file {image}_labelme_auto.json with:</li>\n</ol>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.compare_detections_to_ground_truth", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "compare_detections_to_ground_truth", "kind": "function", "doc": "<p>Match up labels and detections, compare them, and save the results</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.confusion_matrix", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "confusion_matrix", "kind": "function", "doc": "<p>Summarize the results of the comparison. Reads all csvs and creates a confusion matrix</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.STAT_DISTANCE_CUTOFF_PIX", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "STAT_DISTANCE_CUTOFF_PIX", "kind": "variable", "doc": "<p></p>\n", "default_value": "6"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.MOVING_DISTANCE_CUTOFF_PIX", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "MOVING_DISTANCE_CUTOFF_PIX", "kind": "variable", "doc": "<p></p>\n", "default_value": "10"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.COMPARE_DISTANCE_CUTOFF_PIX", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "COMPARE_DISTANCE_CUTOFF_PIX", "kind": "variable", "doc": "<p></p>\n", "default_value": "8"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.CONF_THRESHOLD", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "CONF_THRESHOLD", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.5"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.process_image", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "process_image", "kind": "function", "doc": "<p>Compare the detections and labels for a single image</p>\n\n<p>Args:</p>\n\n<pre><code>detections (str): The directory of detections for the iamge\nlabels_root (str): The root directory of labels\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of clusters in form [x, y, confidence, class, width, height, filename, in_ml, in_manual]\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">detections</span>, </span><span class=\"param\"><span class=\"n\">labels_root</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.compare", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "compare", "kind": "function", "doc": "<p>given two lists of clusters, compare them (cluster them and note the results)\ne.g if ml has the point (52, 101), and manual has (51.8, 101.2), they should be clustered together\n, and this boat should be noted as being in both sets</p>\n\n<p>Args:</p>\n\n<pre><code>ml: list of clusters in form [x, y, confidence, class, width, height, filename]\nmanual: list of clusters in form [x, y, confidence, class, width, height, filename]\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of clusters in form [x, y, ml_class, manual_class]\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ml</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">manual</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.combine_detections_and_labels", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "combine_detections_and_labels", "kind": "function", "doc": "<p>Combine the detections and labels into one list of annotated clusters for comparison</p>\n\n<p>Args:</p>\n\n<pre><code>ml: list of clusters in form [x, y, confidence, class, width, height, filename]\nmanual: list of clusters in form [x, y, confidence, class, width, height, filename]\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of clusters in form [x, y, confidence, class, width, height, filename, source]\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ml</span>, </span><span class=\"param\"><span class=\"n\">manual</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.comparisons_to_csv", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "comparisons_to_csv", "kind": "function", "doc": "<p>Write the comparisons to a csv file</p>\n\n<p>Args:</p>\n\n<pre><code>comparisons: list of clusters in form [x, y, ml_class, manual_class]\nfilename: the name of the file to write to\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">comparisons</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.classifications_to_lat_long", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "classifications_to_lat_long", "kind": "function", "doc": "<p>Convert x and y of image classifications to lat/long and saves csv</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nrun_config (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">run_config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.boat_count_compare", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "boat_count_compare", "kind": "function", "doc": "<p>Column graph with each group being one image, showing number of labelled and number of detected boats next to each other</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.plot_boats", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "plot_boats", "kind": "function", "doc": "<p>given a directory of csvs, plot the boats on the images and save the images</p>\n\n<p>Args:</p>\n\n<pre><code>csvs: directory containing csvs. Must be of form: x, y, ml_class, manual_class\nimgs: base folder with the images (png), or a folder with subfolders with images (stitched.png)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csvs</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">imgs</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.all_mistakes", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "all_mistakes", "kind": "function", "doc": "<p>Given a summary csv, find the images where there is a mistake made.\nSince the x and y in the summary refer to the entire image, we need to\ncalculate the subimage(s) that the boat is in. save the best subimage (most central)\nto a new directory with the type of mistake (e.g \"false_positive\")</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.subimage_confidence", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "subimage_confidence", "kind": "function", "doc": "<p>For config[\"subimage_confidence\"] (int) boats, plot the 16 squares around the boat\nand their confidence scores.</p>\n\n<p>Args:</p>\n\n<pre><code>run_folder (str): The folder to run detection on.\nconfig (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.coverage_heatmap", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "coverage_heatmap", "kind": "function", "doc": "<p>Generate the coverage heatmap for all TIF files used in the run</p>\n\n<p>Args:</p>\n\n<pre><code>    run_folder (str): The folder to run detection on.\n    config (dict): The configuration dictionary.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>    None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">run_folder</span>, </span><span class=\"param\"><span class=\"n\">config</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.all_possible_imgs", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "all_possible_imgs", "kind": "function", "doc": "<p>return a list of tuples (row, col) that would contain the given x and y coords</p>\n\n<p>Args:</p>\n\n<pre><code>x: x coord\ny: y coord\nstride: stride of the images\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of tuples (row, col)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">stride</span><span class=\"o\">=</span><span class=\"mi\">104</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.segregate", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "segregate", "kind": "function", "doc": "<p>Segregate the directory by day and image</p>\n\n<p>Args:</p>\n\n<pre><code>directory (str): The directory to segregate\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>    None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.segregate_by_day", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "segregate_by_day", "kind": "function", "doc": "<p>Separate files in a directory into subdirectories by day.\nFiles must have the date as the last part of the filename.</p>\n\n<p>Args:</p>\n\n<pre><code>directory (str): The directory to segregate\ninto (str): The directory to move the files into\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of directories\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span>, </span><span class=\"param\"><span class=\"n\">into</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.testing.segregate_by_image", "modulename": "ML_Software.counting_boats.boat_utils.testing", "qualname": "segregate_by_image", "kind": "function", "doc": "<p>Separate files in a directory into subdirectories by image.\nFiles must have the image name as the middle part of the filename.</p>\n\n<p>Args:</p>\n\n<pre><code>directory (str): The directory to segregate\ninto (str): The directory to move the files into\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>list of directories\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span>, </span><span class=\"param\"><span class=\"n\">into</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "kind": "module", "doc": "<p>This module contains functions for user interaction and input/output for a CLI tool for counting boats.\nUnfinished, untested, and possibly un-needed.</p>\n\n<p>Author: Charlie Turner\nDate: 17/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.groups", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "groups", "kind": "variable", "doc": "<p></p>\n", "default_value": "[{&#x27;name&#x27;: &#x27;MoretonBayRegion&#x27;, &#x27;aois&#x27;: [&#x27;peel&#x27;, &#x27;south_bribie&#x27;, &#x27;tangalooma&#x27;]}, {&#x27;name&#x27;: &#x27;GBR&#x27;, &#x27;aois&#x27;: [&#x27;keppel&#x27;, &#x27;whitsundays_island_group&#x27;]}]"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.analyse", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "analyse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span>, </span><span class=\"param\"><span class=\"n\">coverage_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.report", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "report", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.save_history", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "save_history", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">history</span>, </span><span class=\"param\"><span class=\"n\">csv_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.archive", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "archive", "kind": "function", "doc": "<p>Deal with folder of raw data after processing</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">coverage_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.new_order", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "new_order", "kind": "function", "doc": "<p>Prompts the user and orders the image from Planet</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.existing_order", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "existing_order", "kind": "function", "doc": "<p>Checks an order and downloads the files</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.boat_utils.user_io_helpers.option_select", "modulename": "ML_Software.counting_boats.boat_utils.user_io_helpers", "qualname": "option_select", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">prompt</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Select an option:&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify", "modulename": "ML_Software.counting_boats.classify", "kind": "module", "doc": "<p>The main file for the pipeline. Classifying boats will be done with this file in most cases.</p>\n\n<p>Requires a config file to be present in the root directory of the project (one level up from this file).\nSee project README for more information on the config file.</p>\n\n<p>Usage:</p>\n\n<ol>\n<li><strong>For Automatic Mode:</strong></li>\n</ol>\n\n<pre><code>python -m counting_boats.classify auto\n</code></pre>\n\n<p>Auto mode will run the entire pipeline: search, order, download, classify, archive, analyse.</p>\n\n<ol start=\"2\">\n<li><p><strong>For Manual Mode:</strong></p>\n\n<p>python -m counting_boats.classify &lt;command></p>\n\n<p>Commands:</p>\n\n<ul>\n<li>archive: Archive the images in the downloads folder.</li>\n<li>search: Search for images on planet. (Not implemented)</li>\n<li>order: Order the given images from Planet. (Not implemented)</li>\n<li>download: Downloads the images from the orders in the input file (Not implemented)</li>\n<li>classify: Run the classifier on the given images in the config file (Not implemented)</li>\n</ul></li>\n</ol>\n\n<p>Not implemented commands will raise a NotImplementedError - all functionality for them is \navailable in either boat_utils/planet_utils.py or boat_utils/user_io_helpers.py.</p>\n\n<p>Author: Charlie Turner</p>\n\n<p>Date: 16/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.classify.COLORS", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS", "kind": "class", "doc": "<p>Colors for the terminal</p>\n"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.OKBLUE", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.OKBLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[94m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.OKGREEN", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.OKGREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[92m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.OKCYAN", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.OKCYAN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[96m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.OKYELLOW", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.OKYELLOW", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[93m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.WARNING", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.WARNING", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[93m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.FAIL", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.FAIL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[91m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.COLORS.ENDC", "modulename": "ML_Software.counting_boats.classify", "qualname": "COLORS.ENDC", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[0m&#x27;"}, {"fullname": "ML_Software.counting_boats.classify.app", "modulename": "ML_Software.counting_boats.classify", "qualname": "app", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;typer.main.Typer object&gt;"}, {"fullname": "ML_Software.counting_boats.classify.archive", "modulename": "ML_Software.counting_boats.classify", "qualname": "archive", "kind": "function", "doc": "<p>Archive the images in the downloads folder.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.auto", "modulename": "ML_Software.counting_boats.classify", "qualname": "auto", "kind": "function", "doc": "<p>Run the entire pipeline automatically.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">skip_order</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">clear</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.batch_mode", "modulename": "ML_Software.counting_boats.classify", "qualname": "batch_mode", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">aois</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">orders_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">download_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">coverage_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">history_len</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">final_date</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">clear</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.batch_search_and_order", "modulename": "ML_Software.counting_boats.classify", "qualname": "batch_search_and_order", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">aoi</span>, </span><span class=\"param\"><span class=\"n\">start_date</span>, </span><span class=\"param\"><span class=\"n\">end_date</span>, </span><span class=\"param\"><span class=\"n\">orders_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.batch_download_with_wait", "modulename": "ML_Software.counting_boats.classify", "qualname": "batch_download_with_wait", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">orders_path</span>, </span><span class=\"param\"><span class=\"n\">download_path</span>, </span><span class=\"param\"><span class=\"n\">start_date</span>, </span><span class=\"param\"><span class=\"n\">end_date</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.search", "modulename": "ML_Software.counting_boats.classify", "qualname": "search", "kind": "function", "doc": "<p>Search for images on planet.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">aoi</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">cloud_cover</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">area_cover</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.get_all_orders", "modulename": "ML_Software.counting_boats.classify", "qualname": "get_all_orders", "kind": "function", "doc": "<p>Get all orders from Planet and save them to an all_orders.csv file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.order", "modulename": "ML_Software.counting_boats.classify", "qualname": "order", "kind": "function", "doc": "<p>Order the given images from Planet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">items</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.download", "modulename": "ML_Software.counting_boats.classify", "qualname": "download", "kind": "function", "doc": "<p>Downloads the images from the orders in the input file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">orders</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.classify.classify", "modulename": "ML_Software.counting_boats.classify", "qualname": "classify", "kind": "function", "doc": "<p>Run the classifier on the given images.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">images</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.plot_output", "modulename": "ML_Software.counting_boats.plot_output", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.plot_output.main", "modulename": "ML_Software.counting_boats.plot_output", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.plot_output.plot", "modulename": "ML_Software.counting_boats.plot_output", "qualname": "plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">NNcsv</span>, </span><span class=\"param\"><span class=\"n\">NNpicture</span>, </span><span class=\"param\"><span class=\"n\">save</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "kind": "module", "doc": "<p>Simple GUI used to reconcile issues with ML detections for labelled images.</p>\n\n<ol>\n<li>Displays an image, and three buttons: \"Boat\", \"Moving Boat\", \"Neither\"</li>\n<li>User clicks the appropriate button, and the result is saved to a CSV file, and that image's labels updated.</li>\n</ol>\n\n<p>Not super useful but left here for reference. General usage was to:\n    label images -> run ML inference -> check labels with this tool -> train the model</p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.label_json_str", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "label_json_str", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;{\\n      &quot;label&quot;: &quot;boat&quot;,\\n      &quot;points&quot;: [\\n        [\\n          0,\\n          0\\n        ],\\n        [\\n          0,\\n          0\\n        ]\\n      ],\\n      &quot;group_id&quot;: null,\\n      &quot;description&quot;: &quot;&quot;,\\n      &quot;shape_type&quot;: &quot;rectangle&quot;,\\n      &quot;flags&quot;: {}\\n    }\\n    &#x27;"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.get_inputs", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "get_inputs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.build_ui", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "build_ui", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.all_possible_imgs", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "all_possible_imgs", "kind": "function", "doc": "<p>return a list of tuples (row, col) that would contain the given x and y coords</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile", "kind": "class", "doc": "<p>Class to reconcile ML detections with labelled images.</p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.__init__", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span></span>)</span>"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.folder", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.folder", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.imgs", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.imgs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.img_idx", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.img_idx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.next_img", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.next_img", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.display_next_image", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.display_next_image", "kind": "function", "doc": "<p>Display next image in folder.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.write_result", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.write_result", "kind": "function", "doc": "<p>Write result</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">result</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.is_boat", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.is_boat", "kind": "function", "doc": "<p>Callback function for \"Boat\" button.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.is_moving_boat", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.is_moving_boat", "kind": "function", "doc": "<p>Callback function for \"Moving Boat\" button.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.reconcile_val_mistakes.Reconcile.is_neither", "modulename": "ML_Software.counting_boats.reconcile_val_mistakes", "qualname": "Reconcile.is_neither", "kind": "function", "doc": "<p>Callback function for \"Neither\" button.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.testing", "modulename": "ML_Software.counting_boats.testing", "kind": "module", "doc": "<p>Testing/Validation Script</p>\n\n<p>Runs a variety of tasks to test the validity of a model. Designed to be used with labelled data.\nConfig file should be a yaml file following the 'config_test.yaml' format.</p>\n\n<p>Author: Charlie Turner\nDate: 16/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.testing.init_run", "modulename": "ML_Software.counting_boats.testing", "qualname": "init_run", "kind": "function", "doc": "<p>Create a new run folder for the validation tasks</p>\n\n<p>Args:\n    config_file (str): path to the config file</p>\n\n<p>Returns:\n    str: path to the new run folder</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.testing.run_tasks", "modulename": "ML_Software.counting_boats.testing", "qualname": "run_tasks", "kind": "function", "doc": "<p>Run a series of tasks. Tasks is a dict of tasks, and any with the\nvalue False will be skipped. Tasks can have subtasks, which will be run\nrecursively. Essentially tasks have to be functions in val_utils.</p>\n\n<p>Args:\n    tasks (dict): dict of tasks to run (or not Run)\n    config (dict): config dict\n    level (int): level of recursion (do not set)</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tasks</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.tile", "modulename": "ML_Software.counting_boats.tile", "kind": "module", "doc": "<p>This one was used create a collage image from multiple smaller images. \nNot documented, not tested, but left here for reference.</p>\n\n<p>Author: Charlie Turner\nDate: 02/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.tile.main", "modulename": "ML_Software.counting_boats.tile", "qualname": "main", "kind": "function", "doc": "<p>Tile the images in the folder.\nimages are named {x}_{y}_{row}_{col}.png\nWe want to create a super image which is a grid of the images increasing column left to right and row top to bottom.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.tile.magnify", "modulename": "ML_Software.counting_boats.tile", "qualname": "magnify", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train", "modulename": "ML_Software.counting_boats.train", "kind": "module", "doc": "<p>Script for training pipeline for a model\nCan be easier to just use command line for training, but this script contains\nthe other steps required - preparing the images, segmenting them, and describing the dataset</p>\n\n<p>Author: Charlie Turner\nDate: 16/09/2024</p>\n"}, {"fullname": "ML_Software.counting_boats.train.app", "modulename": "ML_Software.counting_boats.train", "qualname": "app", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;typer.main.Typer object&gt;"}, {"fullname": "ML_Software.counting_boats.train.parse_config", "modulename": "ML_Software.counting_boats.train", "qualname": "parse_config", "kind": "function", "doc": "<p>Parse the config file</p>\n\n<p>Args:\n    config (str): path to the config file</p>\n\n<p>Returns:\n    dict: the parsed config file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train.prepare", "modulename": "ML_Software.counting_boats.train", "qualname": "prepare", "kind": "function", "doc": "<p>Prepare the TIFF images for labelling by converting them to PNGs\nDoes this for all TIF images in the raw_images folder specified in the config</p>\n\n<p>Args:\n    config (str): path to the config</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train.segment", "modulename": "ML_Software.counting_boats.train", "qualname": "segment", "kind": "function", "doc": "<p>Segment the images and labels into tiles for training.\nAlso split the images into training and validation sets.</p>\n\n<p>Args:\n    config (str): path to the config file\n    train_val_split (float): proportion of images to use for training</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">train_val_split</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train.describe", "modulename": "ML_Software.counting_boats.train", "qualname": "describe", "kind": "function", "doc": "<p>Work out and display:\n    - Number of original images (unique filenames excluding locations)\n    - Number of tiles\n    - Number of labels total\n    - Number of labels per class\n    - Number of images with no labels</p>\n\n<p>Each also as a percentage of total</p>\n\n<h2 id=\"eg\">e.g</h2>\n\n<h2 id=\"training-dataset-statistics\">| Training dataset statistics             |</h2>\n\n<p>| Number of original images: 10           |\n| Number of tiles: 100                    |\n| Number of labels\n|   - Total: 122                          |\n|   - Per class:                          |\n|       - Class 1: 50 (41.67%)            |\n|       - Class 2: 70 (58.33%)            |</p>\n\n<h2 id=\"number-of-images-with-no-labels-2-3\">| Number of images with no labels: 2 (3%) |</h2>\n\n<p>| Validation dataset statistics ...</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train.cull", "modulename": "ML_Software.counting_boats.train", "qualname": "cull", "kind": "function", "doc": "<p>YOLO recommends having 10% of images in the training set with no instances. \nWe can't know how many tiles will have no instances before we segment the images,\nso have to cull down after. This function will remove images with no labels until\n10% of the training set has no labels</p>\n\n<p>Args:\n    config (str): path to the config file</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ML_Software.counting_boats.train.train", "modulename": "ML_Software.counting_boats.train", "qualname": "train", "kind": "function", "doc": "<p>Train the model</p>\n\n<p>Args:\n    config (str): path to the config file</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">typer</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">OptionInfo</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();